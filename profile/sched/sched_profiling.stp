#! /usr/bin/env stap
/**
* Copyright (C) 2009 Universidade Federal de Campina Grande
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* @author thiagoepdc - thiagoepdc@lsd.ufcg.edu.br
*/

/**
this script in based on sched_switch.stp see reference below. we added tid
logging to it

Author: Jason Baron <jbaron@redhat.com>
profiles threads and displays their run times, queued times,
wait times, including i/o wait times.
Has two modes. When no arguments are given it profiles all
threads. Alternatively, you can pass -c "program name"
*/

#TODO: adapt schedtimes.stp to plot tid stats

//constants
global RUNNING=0, QUEUED=1, SLEEPING=2

global target_pid
global state, names
global previous_timestamp
global run_time, sleep_time, queued_time, io_wait_time
global io_wait_count
global io_wait_incremented

function state_calc(state) {
	if(state == 0)
	status = "R"
	if(state == 1)
	status = "S"
	if(state == 2)
	status = "D"
	if(state == 4)
	status = "T"
	if(state == 8)
	status = "T"
	if(state == 16)
	status = "Z"
	if(state == 32)
	status = "EXIT_DEAD"
	return status
}

function get_iowait:long(queue:long) {
    return @cast(queue,"rq","kernel")->nr_iowait->counter
}

function target_sched_off(sched_off_pid) {
    return target_pid == sched_off_pid
}

function target_sched_on(sched_on_pid) {
    return target_pid == sched_on_pid
}

/**
* my deployment (2.6.32-41-generic #94-Ubuntu SMP i686
* SystemTap translator/driver (version 1.0/0.143 Debian version 1.0-2)
* is messing probes so I have to adapt the scheduler.ctxswitch probe
*/

probe kernel.trace("sched_wakeup") {
    #kernel.trace("sched_wakeup") $rq:struct rq* $p:struct task_struct* $success:int

    //sounds odd, eh ?
    wakeup_pid = $p->tgit
    wakeup_tid = $p->pid

    if (target_pid != wakeup_pid) next
    //FIXME: why this check below ?
    if ((!$success) && (state[wakeup_tid] != SLEEPING)) next

    if (!([wakeup_tid] in state)) { /** first probe */
	/** wake-up removes a sleeping task and adds it to the running queue */
        previous_timestamp[wakeup_tid] = gettimeofday_us()
	state[wakeup_tid] = QUEUED
	names[wakeup_tid] = task_execname($p)
    } else if (state[wakeup_tid] == SLEEPING) {
        t = gettimeofday_us()
	sleep_time[wakeup_tid] += (t - previous_timestamp[wakeup_tid])
	if (io_wait_incremented[wakeup_tid] == 1) {
  	    io_wait_time[wakeup_tid] += (t - previous_timestamp[wakeup_tid])
	    io_wait_incremented[wakeup_tid] = 0
    	}
	previous_timestamp[wakeup_tid] = t
        state[wakeup_tid] = QUEUED
	names[wakeup_tid] = task_execname($p)
    } else {
        printf("Illegal. to be waken up one should be sleeping. pid state: %d our state: %d\n",
	        $p->state, state[wakeup_tid])
    }

    /**
    if (target_pid == $p->pid) {
        printf("wakeup %d (%s:%d:%d):%s\n", gettimeofday_ns(), task_execname($p), task_pid($p), task_tid($p), state_calc($p->state))
    }*/
}


/**
* sched_on (QUEUED -> RUNNING)
* sched_off (RUNNING -> QUEUED), (RUNNING ->  SLEEPING)
* wake_up (SLEEPING -> QUEUED)
**/
probe kernel.trace("sched_switch") {
    #kernel.trace("sched_switch") $rq:struct rq* $prev:struct task_struct* $next:struct task_struct*

    prev_pid = $prev->tgid
    prev_tid = $prev->pid
    next_pid = $next->tgid
    next_tid = $next->pid

 /**   if (target_pid == next_pid || target_pid == prev_pid) {
        printf("%d-%d (%s:%d:%d):%s ==> (%s:%d:%d):%s\n",
               task_cpu($prev), gettimeofday_ns(),
               task_execname($prev), task_pid($prev), task_tid($prev), state_calc($prev->state),
               task_execname($next), task_pid($next), task_tid($next), state_calc($next->state))
    }*/

    if (target_sched_off(prev_pid)) {

         if (!([prev_tid] in state)) {/** first probe*/

             previous_timestamp[prev_tid] = gettimeofday_us()
	     names[prev_tid] = task_execname($prev)
	     if ($prev->state > 0) {//FIXME: why > 0 sleeping ?
   	         state[prev_tid] = SLEEPING
	     } else if ($prev->state == 0) {
   	         state[prev_tid] = QUEUED
             } else {
  	         printf("unknown transition pid state: %d our state: %d\n",
		         $prev->state, state[prev_tid])
	     }
	 } else if (state[prev_tid] == RUNNING) {

   	     names[prev_tid] = task_execname($prev)

	     t = gettimeofday_us()
	     run_time[prev_tid] += (t - previous_timestamp[prev_tid])
	     previous_timestamp[prev_tid] = t

	     /* sched_off (RUNNING ->  SLEEPING) */
	     if ($prev->state > 0) {
		  state[prev_tid] = SLEEPING
		  //iowait has increased (in comparison with the time when the task entered the cpu)
	          if ((get_iowait($rq) - io_wait_count[prev_tid]) > 0) {
		      io_wait_incremented[prev_tid] = 1
		  }
	     } else if ($prev->state == 0) {/* sched_off (RUNNING -> QUEUED) */
   	         state[prev_tid] = QUEUED
	     } else {
  	         printf("unknown transition pid state: %d our state: %d\n",
		         $prev->state, state[prev_tid])
	     }
	 } else {
  	     printf("Illegal. It cannot we sched_off if it was not running. %s pid state: %d our state: %d\n",
	             names[prev_tid], $prev->state, state[prev_tid])
	 }
    } else if (target_sched_on(next_pid)) {

	//register the io_wait just before the task receives the cpu, so
	//that we can check later (when the cpu is lost) if it is going to
	//sleep due to IO
        io_wait_count[next_tid] = get_iowait($rq)

	if (!([next_tid] in state)) {/** first probe */
            previous_timestamp[next_tid] =  gettimeofday_us()
            state[next_tid] = RUNNING
	    names[next_tid] = task_execname($next)
	} else if (state[next_tid] == QUEUED) {/* sched_on (QUEUED -> RUNNING) */
  	    t = gettimeofday_us()
	    queued_time[next_tid] += (t - previous_timestamp[next_tid])
	    previous_timestamp[next_tid] = t
	    state[next_tid] = RUNNING
            names[next_tid] = task_execname($next)
	} else {
	    /** it cannot be sched in if it was not queued (the linux running queue),
	        so a transition sleeping -> running is not possible, it has to be
	        waken up before */
            printf("Illegal. It cannot be sched in if it was not queued %s pid state: %d our state: %d\n",
	            names[next_tid], $next->state, state[next_tid])
	}
    }
}

probe begin {
    target_pid = strtol(@1, 10)
}

probe end {
    t = gettimeofday_us()
    foreach (tid in state) {
        if (state[tid] == SLEEPING) {
            sleep_time[tid] += (t - previous_timestamp[tid])
	}
        if (state[tid] == QUEUED) {
   	    queued_time[tid] += (t - previous_timestamp[tid])
	}
        if (state[tid] == RUNNING) {
           run_time[tid] += (t - previous_timestamp[tid])
	}
    }
    printf ("%16s: %6s %10s %10s %10s %10s %10s\n\n",
            "execname", "tid", "run(us)", "sleep(us)", "io_wait(us)", "queued(us)", "total(us)")
    foreach (tid+ in run_time) {
       printf("%16s: %6d %10d %10d %10d %10d %10d\n",
              names[tid], tid, run_time[tid], sleep_time[tid], io_wait_time[tid], queued_time[tid],
	      (run_time[tid] + sleep_time[tid] + queued_time[tid]))
    }
}
